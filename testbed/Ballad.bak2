/* This code is open-source.
 * Images and music are copyrighted by Lasse Ilmonen / ilmoj (2016),
 * and may not be used for commercial use without written permission.
 * Fair Use applies, naturally.
 */
// SDL2 includes
#include <SDL.h>
// Standard C includes
#include <stdio.h>
// .h includes
//#include ""

/*
 *	All declarations that are convenient to be universal
 */

// !! SDL2 pointers: sdl -prefix
// SDL2 window pointer to NULL for error recognition
SDL_Window* sdlWindow = NULL;
SDL_Renderer* sdlRenderer = NULL;

// !! Constants: all caps with underscores
// Screen dimension constants
const int SCREEN_WIDTH = 1080;
const int SCREEN_HEIGHT = 720;
// Size of rectangels used to draw everything, effectively the resolution
const int PIXEL = 2;
// Predefined palettes, all of the colors are from here.
// Two dimensional array, [16][16] is the largest possible due to the nature of imagedata
const int PALETTE[2][16] =
{
	{	0x002B36, 0x073642, 0x586E75, 0x657B83, 0x839496, 0x93A1A1, 0xEEE8D5, 0xFDF6E3,
		0xB58900, 0xCB4B16, 0xDC322F, 0xD33682, 0x6C71C4, 0x268BD2, 0x2AA198, 0x859900 },
	{	0x002B36, 0x073642, 0x586E75, 0x657B83, 0x839496, 0x93A1A1, 0xEEE8D5, 0xFDF6E3,
		0xB58900, 0xCB4B16, 0xDC322F, 0xD33682, 0x6C71C4, 0x268BD2, 0x2AA198, 0x859900 }
};

// Track game state
typedef enum eGameState
{
	QUIT,
	PLAY
} eGameState;
// Set initial game state
eGameState eCurrentState = PLAY;

// Struct for tracking mouse position
struct sMouseEntity {
	int position[2];
};
struct sMouseEntity sMouse;

// Quit SDL2 and it's subsystems
void vSystemQuit();

/*
 *	All in-game functions
 */

// Manage all the input
void vInputManager()
{
	// SDL2 event handle
	SDL_Event sdlE;

	// Track mouse position, starts at middle of screen
	sMouse.position[0] = SCREEN_WIDTH / 2;
	sMouse.position[1] = SCREEN_HEIGHT / 2;
	SDL_GetMouseState( &sMouse.position[0], &sMouse.position[1] );

	// Event queue
	while( SDL_PollEvent( &sdlE ) != 0 )
	{
		if( sdlE.type == SDL_QUIT )
		{
			eCurrentState = QUIT;
		}
		if( sdlE.type == SDL_KEYDOWN )
		{
			switch( sdlE.key.keysym.sym )
			{
				case SDLK_ESCAPE: ;
					eCurrentState = QUIT;
					break;
				default:
					return;
			}
		}
	}
}

/*
 * Game logic
 */
void vLogic()
{
	
}

/*
 * SECTION FOR MAKESHIFT IMAGEDATAS
 */
// 4 bytes to define a single 4x4 grid. Example:
// F0D85A0F =
// 1111 0000 | 1101 1000 | 0101 1010 | 0000 1111
// alp. pal.   bg   fg     4th- 3rd-   2nd- 1st line, binary counters from right
// Alpha byte is a flagbyte, which is converted to 4 levels of alpha for both fg and bg
// Corresponding alpha levels	  Alp=0x00  Alp=0x55  Alp=0xAA  Alp=0xFF
// Foreground alpha only		= 0 (0000), 1 (0001), 2 (0010), 3 (0011)
// Background alpha only		= 0 (0000), 4 (0100), 8 (1000), C (1100)
// Both same alpha				= 0 (0000), 5 (0101), A (1010), F (1111)
//
// First element of image array has some image info. Example:
// 00020002 =
// 0000 0000 | 0000 0002 | 0000 0000 | 0000 0002
// Amount of grids in y-   Amount of grids in x direcion. Currently really empty
int imgSprite[] = { 0x00040003,	0xD0D8112C, 0xF0D8000F, 0x30D88843,
								0xD0D81111, 0xF0D86996, 0x30D88888,
								0xD0D81111, 0xF0D86996, 0x30D88888,
								0xD0D8C211, 0xF0D8F000, 0x30D83488 };
// Screen color info: alpha, palette index, color index
int screenRegular[] = { 0xF06 };
/*
 * /SECTION FOR MAKESHIFT IMAGEDATAS
 */

/*
 * Graphics section
 */

/*
 * Image data preprocessing
 */

// Get just the color of a screen, currently hardcoded to canRegular. Not hardcoded
// to one color because you can use screen shade when backdrop grids have alpha
int* ipGetScreenColor()
{
	static int rgbaArray[4];
	// Get palette index from screen data, this is first because is used to get color index
	rgbaArray[1] = ( screenRegular[0] >> 0x4 ) & 0xF;
	// Get 3 byte color from palette. Uses color index from screen data
	rgbaArray[0] = PALETTE[ rgbaArray[1] ][ ( screenRegular[0] & 0xF ) ];
	// Calc alpha from screen data. Flag only uses lower halfbyte, but often F for clarity. TODO figure if there is EVER any use for this, ofc could layer screen/
	rgbaArray[2] =	( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) | \
					( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) << 0x2 ) ) | \
					( ( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) | \
					( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) << 0x2 ) ) << 0x4 );
	// return address of array: [0]color index, [1]palette color, [2]alpha
	return rgbaArray;
}

// Get image data, currently hardcoded to imgSprite, but once there are more images,
// running one through this is all that's needed to draw a full image
// int** because pointing to address of tetraStream which itself is pointer
int* ipGetImageData( int** ptrToImage )
{
	// Get address of image array, skipping the info element
	*ptrToImage = &imgSprite[1];
	// Array for info about the image
	static int infoArray[3];
	// Calc size of image array
	infoArray[0] = sizeof( imgSprite ) / sizeof( *imgSprite );
	// Get the x width of image
	infoArray[1] = imgSprite[0] & 0xFFFF;
	// Get the y height of image
	infoArray[2] = ( imgSprite[0] >> 0xF ) & 0xFFFF;
	// return address of array: [0]length of image array, [1]x width of image, [2]y height of image
	return infoArray;
}

/*
 * Visual output
 */

// Draw to the screen
void vDrawScreen()
{
	// Set screen color
	// screencolor points to array: [0]color index, [1]palette color, [2]alpha
	int* screenColor = ipGetScreenColor();
	SDL_SetRenderDrawColor( sdlRenderer,	( *( screenColor + 0 ) >> 0x10 ) & 0xFF,// r
											( *( screenColor + 0 ) >> 0x8 ) & 0xFF,// g
											*( screenColor + 0 ) & 0xFF,//b
											*( screenColor + 2 ) );//a
	// Clear screen
	SDL_RenderClear( sdlRenderer );
	// After this draw everything else over the screen

	// Draw a single tetra. The more independent this is, the better
	void drawTetra( int* tetraStream, int drawOrigin[], int cntrTetra, int cntrImageWidth, int cntrImageHeight )
	{
		// Go through tetra from left upper corner to bottom right, drawin each individual tetpix
		// Tetpix counters
		int cntrTetpix;
		int cntrTetpixColumn = 0;
		int cntrTetpixRow = 0;
		for( cntrTetpix = 0; cntrTetpix < 16; cntrTetpix++ )
		{
			int color;
			int alpha;
			// First draw upper line from left to right, then go to next line
			if( cntrTetpixColumn > 3 )
			{
				cntrTetpixColumn = 0;
				cntrTetpixRow++;
			}
			// Use different halfbyte depending on whether current pixel is fg or bg
			if( *( tetraStream + cntrTetra ) & ( 1 << cntrTetpix ) )
			{
				// First halfbyte of data's 4th byte to enter palette and FIRST halfbyte
				// of data's 3rd byte to get index of foreground color
				// Places 3 byte color in col
				color = PALETTE	[ ( *( tetraStream + cntrTetra ) >> 0x18 ) & 0xF ]//palette index
								[ ( *( tetraStream + cntrTetra ) >> 0x10 ) & 0xF ];//color index
				// Going to explain this alpha monstrosity here:
				// Two bits (different two if fg or bg) are duplicated twice with bitfiddling,
				// so that no check needs to be made to determine alpha, you can just CRUNCH it and
				// correct numbers for alpha levels are always achieved. 0x00, 0x55, 0xAA or 0xFF. Example:
				// 0110 10'01' -> 0000 0001 -> 0000 0101 -> 0101 0101. If we call 0000 0001 a, then (a | (a<<2)) | ((a | (a<<2))<<4)
				// Maybe at some point I'll find this is really slow, but for now it's fun.
				alpha = ( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) | \
						( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) << 0x2 ) ) | \
						( ( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) | \
						( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) << 0x2 ) ) << 0x4 );
			}
			else
			{
				// First halfbyte of data's 4th byte to enter palette and SECOND halfbyte
				// of data's 3rd byte to get index of background color
				// Places 3 byte color in col
				color = PALETTE	[ ( *( tetraStream + cntrTetra ) >> 0x18 ) & 0xF ]//palette index
								[ ( *( tetraStream + cntrTetra ) >> 0x14 ) & 0xF ];//color index
				alpha = ( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) | \
						( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) << 0x2 ) ) | \
						( ( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) | \
						( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) << 0x2 ) ) << 0x4 );
			}
			// Define position and size of pixel
			SDL_Rect pixel = {	drawOrigin[0] + ( cntrImageWidth * 4 * PIXEL ) + ( cntrTetpixColumn * PIXEL ),// x
								drawOrigin[1] + ( cntrImageHeight * 4 * PIXEL ) + ( cntrTetpixRow * PIXEL ),// y
								PIXEL,//width
								PIXEL };//height
			// Get 3rd, 2nd & 1st bytes of color for r, g & b
			SDL_SetRenderDrawColor( sdlRenderer,	( color >> 0x10 ) & 0xFF,//r
													( color >> 0x8 ) & 0xFF,//g
													color & 0xFF,//b
													alpha );//a
			// Draw single pixel
			SDL_RenderFillRect( sdlRenderer, &pixel );
			// Inc to next column
			cntrTetpixColumn++;
		}
	}

	// Draw the image
	void drawImage()
	{
		// TODO Make logic for start points of drawing grids
		// Currently origin set to center of screen
		int drawOrigin[] = {SCREEN_WIDTH / 2,//x
							SCREEN_HEIGHT / 2 };//y

		// Fetch image info and data
		// imageData points to array: [0]length of image array, [1]x width of image, [2]y height of image
		// ptr to image can't be returned with rest of array, so returned through ptr to tetraStream
		// *( tetraStream + X ) is used to get the value of element out of the original image array
		int* tetraStream;
		int* imageData = ipGetImageData( &tetraStream );

		// Go through all the tetras in an image
		// Tetra counters, which also get inserted to drawTetra
		int cntrTetra = 0;
		int cntrImageWidth = 0;
		int cntrImageHeight = 0;
		// Drawing finished once counter caps full tetra amount -1 (info element)
		for( cntrTetra = 0; cntrTetra < ( *( imageData ) - 1 ); cntrTetra++ )
		{
			// Go to new tetra row if width counter touches real width (from image info)
			if( cntrImageWidth == *( imageData + 1 ) )
			{
				cntrImageWidth = 0;
				cntrImageHeight++;
			}
			// If alls good, height getting capped should coincide with tetra amount for main loop, not that there's any checks or anything...
			if( cntrImageHeight < *( imageData + 2 ) )
			{
				// !! Drawing a single tetra happens here
				drawTetra( tetraStream, drawOrigin, cntrTetra, cntrImageWidth, cntrImageHeight );
				cntrImageWidth++;
			}
		}
	}
	// Execute image drawing
	drawImage();

	// Update the surface
	SDL_RenderPresent( sdlRenderer );
}

// Everything in the game itself happens here
void vTheLoop()
{
	unsigned int cntrTimeFPS = 0;


	while( eCurrentState != QUIT )
	{
		// Timings. masterTime fetches how long SDL library has been initialized in ms
		// This halts everything so probably causes slowdowns at some point
		// TODO This is really hacky and bruteforce FPS cap. What else needs time?
		unsigned int masterTime = SDL_GetTicks();
		// Only measure input and draw screen again if mastertime has gone certain ms amount, 16ms about 63FPS, 33ms is about 33FPS
		if( masterTime > cntrTimeFPS + 33 )
		{
			vInputManager();
			vLogic();
			vDrawScreen();
			// Reset FPS counter
			cntrTimeFPS = masterTime;
		}
	}
}


/*
 *	Initialize SDL2 and it's subsystems
 */

// Initialize SDL2
int iInitVideo()
{
	if( SDL_Init( SDL_INIT_VIDEO ) != 0 )
	{
		printf( "SDL could not be initialized! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}
// Create window
int iInitWindow()
{
	sdlWindow = SDL_CreateWindow(
			"Ballad",
			SDL_WINDOWPOS_UNDEFINED,
			SDL_WINDOWPOS_UNDEFINED,
			SCREEN_WIDTH,
			SCREEN_HEIGHT,
			SDL_WINDOW_SHOWN /* | SDL_WINDOW_RESIZABLE  | SDL_WINDOW_BORDERLESS */ );
	if( sdlWindow == NULL )
	{
		printf( "Window could not be created! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}
// Create context for Renderer
int iInitRenderer()
{
	sdlRenderer = SDL_CreateRenderer(
			sdlWindow,
			-1,
			SDL_RENDERER_ACCELERATED );
	if( sdlRenderer == NULL )
	{
		printf("Renderer could not be created! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}
// Enables Alpha blending
int iInitBlend()
{
	if( SDL_SetRenderDrawBlendMode( sdlRenderer, SDL_BLENDMODE_BLEND ) != 0 )
	{
		printf( "Blend mode could not be enabled! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}

// Nested initialization
void vSystemInit()
{
	if( iInitVideo() )
	{
		if( iInitWindow() )
		{
			if( iInitRenderer() )
			{
				iInitBlend();
			}
		}
	}
}

/*
 *	Quit SDL2 and it's subsystems
 */

void vSystemQuit()
{
	// Destroy renderer and window
	SDL_DestroyRenderer( sdlRenderer );
	SDL_DestroyWindow( sdlWindow );
	sdlRenderer = NULL;
	sdlWindow = NULL;

	// Quit SDL2 and it's subsystems
	SDL_Quit();
}

/*
 *	Everything in program divided in three: initialization, loop and exiting
 */

void vRunGame()
{
	vSystemInit();
	vTheLoop();
	vSystemQuit();
}

/*
 *	Main
 */

int main( int argc, char* argv[] )
{
	vRunGame();

	return 0;
}
//printf( "xRef:%d	yRef:%d",xRefPos,yRefPos );
//printf( "%d	%d	%d	%d	%d\n",  xSizecntr, xSizeLimit, ySizecntr, ySizeLimit, i );
//printf( "draw x:%d	y:%d	xDev:%d	yDev:%d\n", xRefPos + ( xSizecntr * 4 * PIXEL ) + ( xDev * PIXEL ),yRefPos + ( ySizecntr * 4 * PIXEL ) + ( yDev * PIXEL ), xDev, yDev  );
//printf("s0:%04x	s1:%04x	s2:%04x\n",(*(screenColor)&0xFF),((*(screenColor+1)>>8)&0xFF), ((*(screenColor +2)>>16)&0xFF));
//printf("0:%04x	1:%04x	2:%04x\n",rgbaArray[0],rgbaArray[1], rgbaArray[2]);
//printf( "int: %ld	uint: %ld\n", sizeof( int ), sizeof( unsigned ) );
