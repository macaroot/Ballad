/*	This code is open-source.
 *	Images and music are copyrighted by Lasse Ilmonen / ilmoj (2016),
 *	and may not be used for commercial use without written permission.
 *	Fair Use applies, naturally.
 */
/*	SDL2 includes */
#include <SDL.h>
/*	Standard C includes */
#include <stdio.h>
/*	.h includes */
/*	#include "" */

/*	SECTION FOR MAKESHIFT IMAGEDATAS
 *****************************************************************************/

/*	4 bytes to define a single 4x4 grid. Example:
 *	F0D85A0F =
 *	1111 0000 | 1101 1000 | 0101 1010 | 0000 1111
 *	alp. pal.   bg   fg     4th- 3rd-   2nd- 1st line, binary counters from right
 *	Alpha byte is a flagbyte, which is converted to 4 levels of alpha for both fg and bg
 *	Corresponding alpha levels	  Alp=0x00  Alp=0x55  Alp=0xAA  Alp=0xFF
 *	Foreground alpha only		= 0 (0000), 1 (0001), 2 (0010), 3 (0011)
 *	Background alpha only		= 0 (0000), 4 (0100), 8 (1000), C (1100)
 *	Both same alpha				= 0 (0000), 5 (0101), A (1010), F (1111)
 *
 *	First element of image array has some image info. Example:
 *	00020002 =
 *	0000 0000 | 0000 0002 | 0000 0000 | 0000 0002
 *	Amount of grids in y-   Amount of grids in x direcion. Currently really empty
 */
int imgCursor[] = { 0x00030003,	0xF08E111F, 0x308EF731, 0x008E0000,
								0x308E8CEF, 0xF08EA5A5, 0x308E3100,
								0x008E0000, 0x308E008C, 0x308E0033 };
int imgSquare[] = {	0x00010001, 0xF0A5A5A5 };
/*	Screen color info: alpha, palette index, color index */
int screenRegular[] = { 0xF07 };

/*	/SECTION FOR MAKESHIFT IMAGEDATAS
 *****************************************************************************/

/*	All declarations that are convenient to be universal
 *****************************************************************************/

/*	!! SDL2 pointers: sdl -prefix */
/*	SDL2 window pointer to NULL for error recognition */
SDL_Window* sdlWindow = NULL;
SDL_Renderer* sdlRenderer = NULL;

/*	!! Constants: all caps with underscores */
/*	Screen dimension constants */
const int SCREEN_WIDTH = 1080;
const int SCREEN_HEIGHT = 720;
/*	Temporary consts for amount of tetras needed to fill 1080x720 with tetpix size = 1 so tetra size is 4. 1080/4=270, 720/4=180 */
const int TETRA_ROW = 270;
const int TETRA_COLUMN = 180;
/*	Size of rectangels used to draw everything, effectively the resolution. Currently used just to offset tetpix at draw phase when using SDL_RenderFillRect() */
const int PIXEL = 1;
/*	Predefined palettes, all of the colors are from here. */
/*	Two dimensional array, [16][16] is the largest possible due to the nature of imagedata */
const int PALETTE[2][16] =
{
	{	0x002B36, 0x073642, 0x586E75, 0x657B83, 0x839496, 0x93A1A1, 0xEEE8D5, 0xFDF6E3,
		0xB58900, 0xCB4B16, 0xDC322F, 0xD33682, 0x6C71C4, 0x268BD2, 0x2AA198, 0x859900 },
	{	0x002B36, 0x073642, 0x586E75, 0x657B83, 0x839496, 0x93A1A1, 0xEEE8D5, 0xFDF6E3,
		0xB58900, 0xCB4B16, 0xDC322F, 0xD33682, 0x6C71C4, 0x268BD2, 0x2AA198, 0x859900 }
};

/*	Track game state */
typedef enum eGameState
{
	QUIT,
	PLAY
} eGameState;
/*	Set initial game state */
eGameState eCurrentState = PLAY;

/*	Array of structs into which position and graphic of all to-be-drawn sprites are put */
struct sSpriteEntityList {
	int position[2];
	int* graphic;
};
struct sSpriteEntityList sSprite[10];

/*	Struct for mouse entities */
struct sMouseEntity {
	int position[2];/*	[0]x, [1]y */
	int pressed;/*	hold down flag */
	int* graphic;/*	pointer to imagedata array */
};
struct sMouseEntity sMouse = {	{ 0, 0 },
								0,
								imgCursor };/*	Create and initialize primary mouse entity */

struct sSquareEntity {
	int position[2];/*	[0]x, [1]y */
	int* graphic;/*	pointer to imagedata array */
};
struct sSquareEntity sSquare;

/*	All in-game functions
 *****************************************************************************/

/*	Manage all the input */
void vInputManager()
{
	/*	SDL2 event handle */
	SDL_Event sdlE;

	/*	Track mouse position, updates struct */
	SDL_GetMouseState( &sMouse.position[0], &sMouse.position[1] );

	/*	Event queue */
	while( SDL_PollEvent( &sdlE ) != 0 )
	{
		if( sdlE.type == SDL_QUIT )
		{
			eCurrentState = QUIT;
		}
		if( sdlE.type == SDL_KEYDOWN )
		{
			switch( sdlE.key.keysym.sym )
			{
				case SDLK_ESCAPE: ;
					eCurrentState = QUIT;
					break;
				default:
					return;
			}
		}
		if( sdlE.type == SDL_MOUSEBUTTONDOWN )
		{
			sMouse.pressed = 1;
		}
		if( sdlE.type == SDL_MOUSEBUTTONUP )
		{
			sMouse.pressed = 0;
		}
	}
}

/*	Game logic
 *****************************************************************************/

void vLogic()
{
	sSquare.graphic = imgSquare;
	sSprite[0].position[0] = sMouse.position[0];
	sSprite[0].position[1] = sMouse.position[1];
	sSprite[0].graphic = sMouse.graphic;
	sSprite[1].graphic = sSquare.graphic;
	if( sMouse.pressed )
	{
		sSprite[1].position[0] = sMouse.position[0];
		sSprite[1].position[1] = sMouse.position[1];
	}
}

/*	Image data preprocessing
 *****************************************************************************/

/*	Get just the color of a screen, currently hardcoded to canRegular. Not hardcoded
 *	to one color because you can use screen shade when backdrop grids have alpha
 */
int* ipGetScreenColor()
{
	static int rgbaArray[4];
	/*	Get palette index from screen data, this is first because is used to get color index */
	rgbaArray[1] = ( screenRegular[0] >> 0x4 ) & 0xF;
	/*	Get 3 byte color from palette. Uses color index from screen data */
	rgbaArray[0] = PALETTE[ rgbaArray[1] ][ ( screenRegular[0] & 0xF ) ];
	/*	Calc alpha from screen data. Flag only uses lower halfbyte, but often F for clarity. TODO figure if there is EVER any use for this, ofc could layer screen/ */
	rgbaArray[2] =	( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) | \
					( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) << 0x2 ) ) | \
					( ( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) | \
					( ( ( screenRegular[0] >> 0x8 ) & 0x3 ) << 0x2 ) ) << 0x4 );
	/*	return address of array: [0]color index, [1]palette color, [2]alpha */
	return rgbaArray;
}

/*	Get image data by passing ptr to imagedata array
 *	running one through this is all that's needed to draw a full image
 *	int** because ptrToStream pointing to tetraStream which itself is pointer
 *	TODO the problem with this now that the array had to be given as pointer, is that this doesn't have full access, which sort of messes it's purpose,
 *	Can't get size of array straight, so have to trust info element. Which could be fine
 */
int* ipGetImageData( int** ptrToStream, int* image )
{
	/*	Array for info about the image */
	static int infoArray[3];
	/*	Get address of image array, skipping the info element and place it inside tetraStream */
	*ptrToStream = &image[1];
	/*	Get the x width of image */
	infoArray[1] = image[0] & 0xFFFF;
	/*	Get the y height of image */
	infoArray[2] = ( image[0] >> 0x10 ) & 0xFFFF;
	/*	Calc size of image array from parts extracted from info element */
	infoArray[0] = infoArray[1] * infoArray[2];
	/*	return address of array: [0]length of image array, [1]x width of image, [2]y height of image */
	return infoArray;
}

/*	Visual output
 *****************************************************************************/

/*	Draw a single tetra. The more independent this is, the better */
void drawTetra( int* tetraStream, int drawOrigin[], int cntrTetra, int cntrImageWidth, int cntrImageHeight )
{
	/*	Go through tetra from left upper corner to bottom right, drawing each individual tetpix */
	/*	Tetpix counters */
	int cntrTetpix;
	int cntrTetpixColumn = 0;
	int cntrTetpixRow = 0;
	for( cntrTetpix = 0; cntrTetpix < 16; cntrTetpix++ )
	{
		/*	TODO figure efficient way to skip fully transparent tetras */
		int color;
		int alpha;
		/*	First draw upper line from left to right, then go to next line */
		if( cntrTetpixColumn > 3 )
		{
			cntrTetpixColumn = 0;
			cntrTetpixRow++;
		}
		/*	Use different halfbyte depending on whether current pixel is fg or bg */
		if( *( tetraStream + cntrTetra ) & ( 1 << cntrTetpix ) )
		{
			/*	First halfbyte of data's 4th byte to enter palette and FIRST halfbyte
			 *	of data's 3rd byte to get index of foreground color
			 *	Retrieves 3 byt color
			 */
			color = PALETTE	[ ( *( tetraStream + cntrTetra ) >> 0x18 ) & 0xF ]/*	palette index */
							[ ( *( tetraStream + cntrTetra ) >> 0x10 ) & 0xF ];/*	color index */
			/*	Going to explain this alpha monstrosity here:
			 *	Two bits (different two if fg or bg) are duplicated twice with bitfiddling,
			 *	so that no check needs to be made to determine alpha, you can just CRUNCH it and
			 *	correct numbers for alpha levels are always achieved. 0x00, 0x55, 0xAA or 0xFF. Example:
			 *	0110 10'01' -> 0000 0001 -> 0000 0101 -> 0101 0101. If we call 0000 0001 a, then (a | (a<<2)) | ((a | (a<<2))<<4)
			 *	Maybe at some point I'll find this is really slow, but for now it's fun.
			 */
			alpha = ( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) | \
					( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) << 0x2 ) ) | \
					( ( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) | \
					( ( ( *( tetraStream + cntrTetra ) >> 0x1C ) & 0x3 ) << 0x2 ) ) << 0x4 );
		}
		else
		{
			/*	First halfbyte of data's 4th byte to enter palette and SECOND halfbyte */
			/*	of data's 3rd byte to get index of background color */
			/*	Places 3 byte color in col */
			color = PALETTE	[ ( *( tetraStream + cntrTetra ) >> 0x18 ) & 0xF ]/*	palette index */
							[ ( *( tetraStream + cntrTetra ) >> 0x14 ) & 0xF ];/*	color index */
			alpha = ( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) | \
					( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) << 0x2 ) ) | \
					( ( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) | \
					( ( ( *( tetraStream + cntrTetra ) >> 0x1E ) & 0x3 ) << 0x2 ) ) << 0x4 );
		}
/**/
/**/	/* Define position and size of pixel */
/*		SDL_Rect pixel = {	drawOrigin[0] + ( cntrImageWidth * 4 * PIXEL ) + ( cntrTetpixColumn * PIXEL ), */ /*	x */
/*							drawOrigin[1] + ( cntrImageHeight * 4 * PIXEL ) + ( cntrTetpixRow * PIXEL ), */ /*	y */
/*							PIXEL, */ /*	width */
/*							PIXEL }; */ /*	height */
/**/
		/*	Get 3rd, 2nd & 1st bytes of color for r, g & b */
		SDL_SetRenderDrawColor( sdlRenderer,	( color >> 0x10 ) & 0xFF,/*	r */
												( color >> 0x8 ) & 0xFF,/*	g */
												color & 0xFF,/*	b */
												alpha );/*	a */
/**/
/**/	/*	Draw single tetpix */
/*		SDL_RenderFillRect( sdlRenderer, &pixel ); */
/**/
		/*	Draw single tetpix, which is an actual pixel, PIXEL would be assumed 1 */
		SDL_RenderDrawPoint( sdlRenderer,	drawOrigin[0] + ( cntrImageWidth * 4 ) + cntrTetpixColumn,/*	x */
											drawOrigin[1] + ( cntrImageHeight * 4 ) + cntrTetpixRow );/*	y */
		/*	Inc to next column */
		cntrTetpixColumn++;
	}
}

/*	Draw the image */
void drawImage( int currentImageIndex )
{
	int drawOrigin[2];
	int* tetraStream;
	int* imageData;
	int cntrTetra;
	int cntrImageWidth;
	int cntrImageHeight;
	/*	TODO Make logic for start points of drawing grids */
	/*	Currently not universal, draws everything to mouse */
	drawOrigin[0] = sSprite[ currentImageIndex ].position[0];/*	x */
	drawOrigin[1] = sSprite[ currentImageIndex ].position[1];/*	y */

	/*	Fetch image info and data
	 *	imageData points to array: [0]length of image array, [1]x width of image, [2]y height of image
	 *	ptr to image can't be returned with rest of array, so returned through ptr to tetraStream
	 *	*( tetraStream + X ) is used to get the value of element out of the original image array
	 */
	imageData = ipGetImageData( &tetraStream, sSprite[ currentImageIndex ].graphic );

	/*	Go through all the tetras in an image */
	/*	Tetra counters, which also get inserted to drawTetra */
	cntrTetra = 0;
	cntrImageWidth = 0;
	cntrImageHeight = 0;
	/*	Drawing finished once counter caps full tetra amount */
	for( cntrTetra = 0; cntrTetra < *( imageData ); cntrTetra++ )
	{
		/*	Go to new tetra row if width counter touches real width (from image info) */
		if( cntrImageWidth == *( imageData + 1 ) )
		{
			cntrImageWidth = 0;
			cntrImageHeight++;
		}
		/*	If alls good, height getting capped should coincide with tetra amount for main loop, not that there's any checks or anything... */
		if( cntrImageHeight < *( imageData + 2 ) )
		{
			/*	!! Drawing a single tetra happens here */
			drawTetra( tetraStream, drawOrigin, cntrTetra, cntrImageWidth, cntrImageHeight );
			cntrImageWidth++;
		}
	}
}


/*	Draw to the screen */
void vDrawScreen()
{
	int cntrSprites;
	/*	Set screen color */
	/*	screencolor points to array: [0]color index, [1]palette color, [2]alpha */
	int* screenColor = ipGetScreenColor();
	SDL_SetRenderDrawColor( sdlRenderer,	( *( screenColor + 0 ) >> 0x10 ) & 0xFF,/*	r */
											( *( screenColor + 0 ) >> 0x8 ) & 0xFF,/*	g */
											*( screenColor + 0 ) & 0xFF,/*	b */
											*( screenColor + 2 ) );/*	a */
	/*	Clear screen */
	SDL_RenderClear( sdlRenderer );
	/*	After this draw everything else over the screen */

	/*	Execute image drawing */
	/*	Currently segfaults if goes over 1 TODO figure safe way to walk sSprites[] */
	for( cntrSprites = 0; cntrSprites < 2; cntrSprites++ )
	{
		drawImage( cntrSprites );
	}

	/*	Update the surface */
	SDL_RenderPresent( sdlRenderer );
}

/*	Everything in the game itself happens here */
void vTheLoop()
{
	/*	End game when state is QUIT */
	while( eCurrentState != QUIT )
	{
		/*	SDL_Delay() halts everything for ms, so might cause slowdowns at some point
		 *	TODO What else needs time. SDL_GetTicks() fetches how long SDL library has been initialized in ms
		 *	16ms about 63FPS, 33ms is about 33FPS
		 */
	/*	unsigned int masterTime = SDL_GetTicks(); */
		SDL_Delay(33);
		vInputManager();
		vLogic();
		vDrawScreen();
	}
}

/*	Just so inits find it */
void vSystemQuit();

/*	Initialize SDL2 and it's subsystems
 *****************************************************************************/

/*	Initialize SDL2 */
int iInitVideo()
{
	if( SDL_Init( SDL_INIT_VIDEO ) != 0 )
	{
		printf( "SDL could not be initialized! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}
/*	Create window */
int iInitWindow()
{
	sdlWindow = SDL_CreateWindow(
			"Ballad",
			SDL_WINDOWPOS_UNDEFINED,
			SDL_WINDOWPOS_UNDEFINED,
			SCREEN_WIDTH,
			SCREEN_HEIGHT,
			SDL_WINDOW_SHOWN /* | SDL_WINDOW_RESIZABLE  | SDL_WINDOW_BORDERLESS */ );
	if( sdlWindow == NULL )
	{
		printf( "Window could not be created! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}
/*	Create context for Renderer */
int iInitRenderer()
{
	sdlRenderer = SDL_CreateRenderer(
			sdlWindow,
			-1,
			SDL_RENDERER_ACCELERATED );
	if( sdlRenderer == NULL )
	{
		printf("Renderer could not be created! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}
/*	Enables Alpha blending */
int iInitBlend()
{
	if( SDL_SetRenderDrawBlendMode( sdlRenderer, SDL_BLENDMODE_BLEND ) != 0 )
	{
		printf( "Blend mode could not be enabled! SDL_Error: %s\n",
				SDL_GetError() );
		return 0;
		vSystemQuit();
	}
	return 1;
}

/*	Nested initialization */
void vSystemInit()
{
	if( iInitVideo() )
	{
		if( iInitWindow() )
		{
			if( iInitRenderer() )
			{
				iInitBlend();
				/*	Hide OS cursor */
				SDL_ShowCursor(SDL_DISABLE);
			}
		}
	}
}

/*	Quit SDL2 and it's subsystems
 *****************************************************************************/

void vSystemQuit()
{
	/*	Destroy renderer and window */
	SDL_DestroyRenderer( sdlRenderer );
	SDL_DestroyWindow( sdlWindow );
	sdlRenderer = NULL;
	sdlWindow = NULL;

	/*	Quit SDL2 and it's subsystems */
	SDL_Quit();
}

/*	Everything in program divided in three: initialization, loop and exiting
 *****************************************************************************/

void vRunGame()
{
	vSystemInit();
	vTheLoop();
	vSystemQuit();
}

/*	Main
 *****************************************************************************/

int main( int argc, char* argv[] )
{
	vRunGame();

	return 0;
}
/*	Debug printfs:
 *	printf( "xRef:%d	yRef:%d",xRefPos,yRefPos );
 *	printf( "%d	%d	%d	%d	%d\n",  xSizecntr, xSizeLimit, ySizecntr, ySizeLimit, i );
 *	printf( "draw x:%d	y:%d	xDev:%d	yDev:%d\n", xRefPos + ( xSizecntr * 4 * PIXEL ) + ( xDev * PIXEL ),yRefPos + ( ySizecntr * 4 * PIXEL ) + ( yDev * PIXEL ), xDev, yDev  );
 *	printf("s0:%04x	s1:%04x	s2:%04x\n",(*(screenColor)&0xFF),((*(screenColor+1)>>8)&0xFF), ((*(screenColor +2)>>16)&0xFF));
 *	printf("0:%04x	1:%04x	2:%04x\n",rgbaArray[0],rgbaArray[1], rgbaArray[2]);
 *	printf( "int: %ld	uint: %ld\n", sizeof( int ), sizeof( unsigned ) );
 */
